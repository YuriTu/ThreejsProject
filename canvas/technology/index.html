<!DOCTYPE html>
<html >
<head>
<meta charset="utf-8">
<meta name="google" value="notranslate">
<meta name="robots" content="noindex">
<title>7款HTML5 Canvas全屏背景动画特效01</title>
<style>
canvas { position: absolute; top: 0; left: 0; }

/* Demo Buttons Style */
.codrops-demos {
	font-size: 0.8em;
	text-align:center;
	position:absolute;
	z-index:99;
	width:96%;
}

.codrops-demos a {
	display: inline-block;
	margin: 0.35em 0.1em;
	padding: 0.5em 1.2em;
	outline: none;
	text-decoration: none;
	text-transform: uppercase;
	letter-spacing: 1px;
	font-weight: 700;
	border-radius: 2px;
	font-size: 110%;
	border: 2px solid transparent;
	color:#fff;
}

.codrops-demos a:hover,
.codrops-demos a.current-demo {
	border-color: #383a3c;
}
</style>
</head>

<body>

<nav class="codrops-demos">
	<a class="current-demo" href="index.html">Demo 1</a>
	<a href="index2.html">Demo 2</a>
	<a href="index3.html">Demo 3</a>
	<a href="index4.html">Demo 4</a>
	<a href="index5.html">Demo 5</a>
	<a href="index6.html">Demo 6</a>
	<a href="index7.html">Demo 7</a>
</nav>

<canvas id="c"></canvas>

<script type="text/javascript">
var w = c.width = window.innerWidth,
h = c.height = window.innerHeight,
ctx = c.getContext('2d'),
opts = {
    len: 20,//移动长度的限制
    count: 50,//数量
    baseTime: 10,//基础时间
    addedTime: 10,//添加时间
    dieChance: .05,//消失的几率
    spawnChance: 1,//产生线条的几率
    sparkChance: .1,//闪烁几率
    sparkDist: 10,//闪烁距离
    sparkSize: 2,//闪烁的尺寸
    color: 'hsl(hue,100%,light%)',//颜色，其中hue和light是占位符
    baseLight: 50,//基础亮度，用在颜色的占位符中
    addedLight: 10,//增加的亮度
    shadowToTimePropMult: 6,
    baseLightInputMultiplier: .01,
    addedLightInputMultiplier: .02,
    cx: w / 2,//中心点的坐标
    cy: h / 2,
    repaintAlpha: .04,//重绘的透明度，产生尾巴效果
    hueChange: .1//颜色中hue增加的系数
},
tick = 0,
lines = [],
//屏幕宽度/2/线条长度  也就是最大的位置，超过这个位置就消失
dieX = w / 2 / opts.len,
dieY = h / 2 / opts.len,
baseRad = Math.PI * 2 / 6; //120度角，就是六边形的角度
ctx.fillStyle = 'black';//背景颜色
ctx.fillRect(0, 0, w, h);//绘制背景

function loop() {
	window.requestAnimationFrame(loop); ++tick;
	ctx.globalCompositeOperation = 'source-over';//绘制的覆盖方式
	ctx.shadowBlur = 0;//阴影模糊
    //这里用的就是占位符替换，把设置的变量替换进去
	ctx.fillStyle = 'rgba(0,0,0,alp)'.replace('alp', opts.repaintAlpha);
    //绘制背景，因为每次绘制背景的时候都没有擦除之前的绘制，
    //加上这里绘制的透明度是0.04，所以就形成了尾巴的效果
	ctx.fillRect(0, 0, w, h);
	ctx.globalCompositeOperation = 'lighter';//再次更改覆盖方式，为之后的绘制做准备
    //如果线条少于预定的数量，则产生新的线条
	if (lines.length < opts.count  && Math.random() < opts.spawnChance) lines.push(new Line);
	lines.map(function(line) {
		line.step()
	})
}
function Line() {
	this.reset()//定义一个Line的构造函数，用来生成线条
}
Line.prototype.reset = function() {
    //线条初始化
    this.x = 0;//初始位置
    this.y = 0;
    this.addedX = 0;//递增距离
    this.addedY = 0;
    this.rad = 0;//初始角度
//    颜色系数
	this.lightInputMultiplier = opts.baseLightInputMultiplier + opts.addedLightInputMultiplier * Math.random();
    //替换掉颜色中hue占位符，使用  记号*变化系数
	this.color = opts.color.replace('hue', tick * opts.hueChange);
    //累计的时间
	this.cumulativeTime = 0;
    //执行绘制方法
	this.beginPhase()
}
//设定参数
Line.prototype.beginPhase = function() {
	this.x += this.addedX;//位置 = 原先的位置+递增的距离
	this.y += this.addedY;
	this.time = 0;
    // 目标消失时间 = 基础时间 + 递增的时间*随机数


	this.targetTime = (opts.baseTime + opts.addedTime * Math.random());
    //角度 += 120 或 -120中的一个角度
	this.rad += baseRad * (Math.random() < .5 ? 1 : -1);
	this.addedX = Math.cos(this.rad); //设置增加的距离
	this.addedY = Math.sin(this.rad);
    //消失的概率
    //判断时候超过 设定的消失的边界
	if (Math.random() < opts.dieChance
		|| this.x > dieX
		|| this.x < -dieX
		|| this.y > dieY
		|| this.y < -dieY) this.reset()
}
Line.prototype.step = function() {
    //运行时间递增
    ++this.time;
    //累积时间递增
    ++this.cumulativeTime;
    //如果时间大于目标时间 则重新设置参数
	if (this.time >= this.targetTime) this.beginPhase();

	var prop = this.time / this.targetTime,//这一段几率线条旁边点的位置
	wave = Math.sin(prop * Math.PI / 2),//wave在-1 到1之间
	x = this.addedX * wave,
	y = this.addedY * wave;
	ctx.shadowBlur = prop * opts.shadowToTimePropMult;//绘制是的阴影模糊
    //填充颜色和阴影颜色
    //绘制线条中点的x.y坐标，因为拖尾巴的缘故，显示的是线条
//   亮度 =  /基础亮度，用在颜色的占位符中 + 亮度增加max （* math.sin(经过的时间 * 亮度系数) ） 这就是个0-1的值，没必要这么麻烦
//       亮度系数 =  基础亮度系数 + 增量 * random
	ctx.fillStyle = ctx.shadowColor = this.color.replace('light', opts.baseLight + opts.addedLight * Math.sin(this.cumulativeTime * this.lightInputMultiplier));
    //点的大小
    //绘制闪烁点
	ctx.fillRect(
	    opts.cx + (this.x + x) * opts.len,
		opts.cy + (this.y + y) * opts.len,
		2, 2);
	if (Math.random() < opts.sparkChance){
        ctx.fillRect(
//            中央坐标 + （目前线条位置 + 增量） * 线条长度  + 【0 -1 】闪烁距离 * 【-1 1】 - 一半的闪烁
            opts.cx + (this.x + x) * opts.len + Math.random() * opts.sparkDist * (Math.random() < .5 ? 1 : -1) - opts.sparkSize / 2,
			opts.cy + (this.y + y) * opts.len + Math.random() * opts.sparkDist * (Math.random() < .5 ? 1 : -1) - opts.sparkSize / 2,
			opts.sparkSize,
			opts.sparkSize)
	}
}
loop();
window.addEventListener('resize',
function() {
	w = c.width = window.innerWidth;
	h = c.height = window.innerHeight;
	ctx.fillStyle = 'black';
	ctx.fillRect(0, 0, w, h);
	opts.cx = w / 2;
	opts.cy = h / 2;
	dieX = w / 2 / opts.len;
	dieY = h / 2 / opts.len
});
</script>

</body>
</html>
